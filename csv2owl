#!/usr/bin/env python3
import re

import click
import csv

import rdflib
import sys
from rdflib.namespace import RDF, RDFS, OWL, SKOS

DEFAULT_NAMESPACE = RDFS
NAMESPACES = {}


class NotMatchingNamespaceValue(Exception):
    pass


class UnknownNamespace(Exception):
    pass


def split_namespace_value(string):
    pattern = re.compile(r'\s*(?P<namespace>[^:]+):(?P<value>\w+)\s*')
    matches = pattern.search(string)
    if not matches:
        raise NotMatchingNamespaceValue(f'{string} does not match namespace:value')

    namespace, value = matches.group('namespace'), matches.group('value')
    namespace = namespace.upper()

    if namespace in NAMESPACES.keys():
        return NAMESPACES[namespace], value
    elif hasattr(rdflib.namespace, namespace.upper()):
        return getattr(rdflib.namespace, namespace.upper()), value
    else:
        raise UnknownNamespace(f'\'{namespace}\'')



def get_uri(string, force=True):
    string = string.strip()
    if ' ' in string:
        return None
    try:
        namespace, value = split_namespace_value(string)
    except NotMatchingNamespaceValue:
        if force:
            return DEFAULT_NAMESPACE[string]
        return None
    except UnknownNamespace as e:
        if not force:
            return None
        raise e

    return namespace[value]


def setup_graph(graph, config):
    for namespace, uri in NAMESPACES.items():
        graph.bind(namespace.lower(), uri)


def handle_prefix(prefix_file, delimiter=','):
    global DEFAULT_NAMESPACE
    prefix_reader = csv.reader(prefix_file, delimiter=delimiter)

    for row in prefix_reader:
        row = [field.strip() for field in row]
        namespace = rdflib.Namespace(row[2])
        NAMESPACES[row[1].upper()] = namespace
        if 'default' in row[0]:
            DEFAULT_NAMESPACE = namespace


def handle_file(graph, f, file_type, delimiter=','):
    file_reader = csv.reader(f, delimiter=delimiter)
    field_names = next(file_reader)
    type_rows = list(file_reader)

    current_value = None
    for row in type_rows:
        current = get_uri(row[0])
        for index, field_value, in enumerate(row[1:], 1):
            field_value = field_value.strip()
            if not field_value:
                continue
            force_uri = field_names[index] not in ['label', 'comment']


            value = get_uri(field_value, force=force_uri) or rdflib.Literal(field_value, lang=lang)
            graph.add((current, get_uri(field_names[index]), value))


@click.command()
@click.argument('classes', type=click.File('r'))
@click.argument('properties', type=click.File('r'))
@click.option('--prefix', '-p', default=None, help='Prefix CSV File', type=click.File('r'))
@click.option('--delimiter', '-d', default=',', help='CSV delimiter character')
@click.option('--config', '-c', default=None, help='Config file path')
@click.option('--output', '-o', default=sys.stdout, help='Output file', type=click.File('w'))
@click.option('--format', '-f', default='json-ld', help='Output format')
def csv2owl(classes, properties, prefix, delimiter, config, output, format):
    graph = rdflib.Graph()
    if prefix:
        handle_prefix(prefix, delimiter)
    setup_graph(graph, config)
    handle_file(graph, classes, 'classes', delimiter)
    handle_file(graph, properties, 'properties', delimiter)
    print(graph.serialize(format=format, indent=4).decode('utf8'), file=output)
    pass


if __name__ == '__main__':
    csv2owl()
